---
title: Creating the Service Author Deliverables
owner: London Services Enablement
---

This topic describes how to create the deliverables required from service authors.

##<a id="what-is-required-of-the-service-authors"></a>Service Author Requirements

The following deliverables are required from service authors:

- Service release(s)
- BOSH release(s) to be deployed by the manifest that is generated by the Service Adapter
- Service Adapter BOSH release that contains the Service Adapter CLI
- Documentation for the operator to configure plan definitions for the Service Adapter
- Documentation for the operator to backup and restore service instances

For information about the responsibilities of operators, see [Operator Responsibilities](operating.html#operator).

## <a id="create-a-service-release"></a>Create a Service Release

A service release is a BOSH release that is deployed at instance creation time, once for each service instance, by the on-demand broker (ODB). 

For examples of a service release, see the following:

* [Redis](https://github.com/pivotal-cf-experimental/redis-example-service-release)
* [Kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-release)

For more information about how to create a BOSH release, see the [BOSH docs](http://bosh.io/docs). 
Pivotal recommends creating sample manifests that deploy the service release(s), as this will help you write the `generate-manifest` component of the Service Adapter later.

### <a id="service-instance-lifecycle-errands"></a>Service Instance Lifecycle Errands

 <p class="note"><strong>Note</strong>: This feature requires BOSH director v261 or later.</p>

A service release can provide job errands that are used by ODB during the management of an instance lifecycle. 
Operators can configure service instance lifecycle errands. For more information, see [Service Instance Lifecycle Errands](./operating.html#lifecycle-errands).

ODB supports the following service instance lifecycle errands:

- `post-deploy`: This errand runs after the creation or updating of a service instance. For more information about the workflow, see [Create/Update Service Instance with Post-Deploy Errands](./concepts.html#post-deploy).
- `pre-delete`: This errand runs before the deletion of a service instance. For more information about the workflow, see [Delete Service Instance with Pre-Delete Errand](./concepts.html#pre-delete).

A deployment is only considered successful if along with the deployment all lifecycle errands complete successfully.

See an example implementation of a health check `post-deploy` job in the [example Redis release](https://github.com/pivotal-cf-experimental/redis-example-service-release/tree/master/jobs/health-check).

If you are using the [generate-manifest](#generate-manifest) command, you must validate and include any supported errands that are specified in the instance groups array.

#### Colocated Errands

<p class="note"><strong>Note</strong>: This feature requires BOSH director v263 or later.</p>

Both `post-deploy` and `pre-delete` errands can be run as colocated errands. 
Colocated errands run on an existing service instance group, avoiding additional resource allocation.

In order to enable a new colocated errand, they must be added to the list of jobs of an instance group.

For more information see the [BOSH documentation](https://bosh.io/docs/errands.html).

### <a id="job-links"></a>Job Links

When generating a manifest, Pivotal recommends not using static IPs, which make network IP management very complex. Instead, Pivotal recommends using [BOSH's job links feature](https://bosh.io/docs/links.html).

There are two types of job links, implicit and explicit. The [example Kafka release](https://github.com/pivotal-cf-experimental/kafka-example-service-release/blob/master/jobs/kafka_server/spec#L15) uses implicit job links to get the IPs of the brokers and the zookeeper. For more information about the links feature, see the [BOSH documentation](https://bosh.io/docs/links.html).

## <a id="create-a-service-adapter"></a>Create a Service Adapter

A Service Adapter is an executable invoked by ODB. It is expected to respond to these subcommands:

- `generate-manifest`:
  Generate a BOSH manifest for your service instance deployment and output to stdout as YAML, given information about the:
  - BOSH Director (stemcells, release names)
  - service instance (ID, request parameters, plan properties, IAAS resources)
  - previous manifest, if this is an upgrade deployment

    <p class="note"><strong>Note</strong>: ODB requires <code>generate-manifest</code> to be idempotent.
    Given the same arguments when a previous manifest is supplied&mdash;which
    happens during a deployment update&mdash;the command should always output
    the same BOSH manifest.</p>

- `dashboard-url`:
  Generate an optional URL of a web-based management user interface for the service instance.

- `generate-plan-schemas`:
  Generate a JSON schema to validate service-specific configuration parameters. 
  It requires the JSON of a service plan passed via the `--plan-json` flag.

- `create-binding`:
  Create (unique, if possible) credentials for the service instance, printing them to stdout as JSON.

- `delete-binding`:
  Invalidate the created credentials, if possible. Some services (e.g. Redis) are single-user, and this endpoint will do nothing.

The parameters, and expected output from these subcommands will be explained in detail below. For each of these subcommands, exit status 0 indicates that the command succeeded exit status 10 indicates not implemented, and any non-zero status indicates failure.

### <a id="handling-errors"></a>Handle Errors

If a subcommand fails, the adapter must return a non-zero exit status, and may optionally print to stdout and/or stderr.

When a subcommand exits with an unrecognized exit code anything printed to stdout will be returned to the CF CLI user.

Both the stdout and stderr streams will be printed in the broker log for the operator. For that reason, we recommend not printing the manifest or other sensitive details to stdout/stderr, as the ODB does no validation on this output.

See an example implementation [here](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/892d48b066c9b1d2651080484a53531001e9e920/adapter/create_binding.go#L27-L29).

## <a id="manifest"></a>Inputs for Manifest Generation

### <a id="request-params"></a>Request Parameters

The [body](https://docs.cloudfoundry.org/services/api.html#provisioning) of the provision request from Cloud Controller, including arbitrary parameters from the CLI user.

Service authors can choose to allow Cloud Foundry users to configure service instances with arbitrary parameters. See the PCF docs on [Managing Service Instances with the CLI](https://docs.pivotal.io/pivotalcf/devguide/services/managing-services.html). Arbitrary parameters can be passed to the service adapter when creating, or updating a service instance. They allow Cloud Foundry users to override the default configuration for a service plan.

Service authors must document the usage of arbitrary parameters for Cloud Foundry users.

For example, the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports the `auto_create_topics` arbitrary parameter to configure auto-creation of topics on the cluster.

### <a id="prev-props"></a>Previous Manifest Properties

When updating a service instance, service authors must migrate certain properties 
for the service from the previous manifest. 
If the previous manifest contains values specified by arbitrary parameters, 
the service adapter **must** get those values from the previous manifest and add them to the new manifest.

<p class="note warning"><strong>WARNING</strong>:
  If the service adapter does not migrate properties from the old manifest to 
  the new one, the update fails.</p>

For example, the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/94efd8e495c7f2008ad8c2bdb322affd56b3ead9/adapter/generate_manifest.go#L100-L109) 
migrates the `auto_create_topics` previous plan property to configure auto-creation of topics on the cluster.

### <a id="plan-props"></a>Service Plan Properties

Service authors can choose to support certain properties for the service in the adapter code. These properties are service-specific traits used to customize the service. They do not necessarily map to jobs one to one; a plan property may affect multiple jobs in the deployment. Plan properties are a mechanism for the operator to define different plans.

Service authors must document the usage of plan properties for the operator.

See the following examples:

- The [Redis service adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/<%= vars.odb_example_redis_service_adapter_version %>/adapter/redis_manifest_generator.go) supports the `persistence` property which can be used to attach a disk to the VM.
- The [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports the `auto_create_topics` property to enable auto-creation of topics on the cluster.

### <a id="precedence"></a>Order of Precedence

Note, we recommend service authors use the following order of precedence in their service adapters when generating manifests:

1. Arbitrary parameters
1. Previous manifest properties
1. Plan properties

For example, see `auto_create_topics` in the [example Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L68-L77).

### <a id="defensive-upgrade-behaviors"></a> Defensive Upgrade Behaviors for Stemcells or Releases

Service Authors should ensure that the service release or the stemcell satisfies the functional requirements of the service adapter. This can be achieved, for example, by checking that the service release satisfies a minimum version constraint.

The [generate manifest subcommand for the Kafka example](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/ab99f9086c63396464347b585fb3f2abad6e332c/adapter/generate_manifest.go#L86) has an example of this approach.

## <a id="interface"></a>Service Adapter Interface

Implement your service adapter as a binary. The service adapter receives its parameters as a JSON document using stdin.

For a list of possible subcommands and the JSON document structure, 
see the [Subcommands](#sub-commands) section below.

For example service adapters, see the following examples written in Golang:

* [Redis](https://github.com/pivotal-cf-experimental/redis-example-service-adapter)
* [Kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter).

<p class="note"><strong>Note: </strong> The Redis and Kafka examples above use SDK to help with 
  cross-cutting concerns. For example, reading the JSON document from stdin.</p>

### <a id="sub-commands"></a>Subcommands

#### <a id="generate-manifest"></a>generate-manifest

For more information about the `generate-manifest` subcommand, 
see the following sections:

- [Input Parameters](#generate-manifest-parameters)
- [Output](#generate-manifest-output)

<div class="note">
  <strong>Notes</strong>:
  <ul>
  <li>ODB requires <code>generate-manifest</code> to be <strong>idempotent</strong>.
    Given the same arguments when a previous manifest is
    supplied&mdash;which happens during a deployment update&mdash;the command
    should always output the same BOSH manifest.</li> <li>When determing
    whether there are pending changes for an instance during an update, ODB
    <em>ignores</em> any configuration supplied in the <a
    href="https://bosh.io/docs/deployment-manifest.html#update"
    target="_blank">update block of the manifest</a> returned by the
    <code>generate-manifest</code> subcommand.</li>
  </ul>
</div>


##### <a id="generate-manifest-parameters"></a>Input Parameters

The following section details the parameters provided to the `generate-manifest` 
subcommand using stdin.

See the following example:

```json
{
  "generate_manifest": {
    "service_deployment": "SERVICE-DEPLOYMENT-JSON",
    "plan": "PLAN-JSON",
    "previous_plan": "PREVIOUS-PLAN-JSON",
    "previous_manifest": "PREVIOUS-MANIFEST",
    "request_parameters": "REQUEST-PARAMETERS-JSON"
  }
}
```

All the arguments will be passed as strings and not JSON objects. 
See the following example:

```not-json
{
  "generate_manifest": {
    "service_deployment": "{\"deployment_name\":\"some-name\"...}"
    // ...
  }
}

```

**<a id="service-deployment"></a>SERVICE-DEPLOYMENT-JSON**

The following table describes the JSON structure required for `SERVICE-DEPLOYMENT-JSON`:

Provides information regarding the BOSH Director

| field                     | Type              | Description                                                            |
|:--------------------------|:------------------|:-----------------------------------------------------------------------|
| deployment_name           | string            | name of the deployment on the Director, in the format `service-instance_$guid`|
| releases                  | array of releases | list of service releases configured for the deployment by the operator |
| release.name              | string            | name of the release on the Director                                    |
| release.version           | string            | version of the release                                                 |
| release.jobs              | array of strings  | list of jobs required from the release                                 |
| stemcell                  | map               | the stemcell available on the Director                                 |
| stemcell.stemcell_os      | string            | stemcell OS available on the Director                                  |
| stemcell.stemcell_version | string            | stemcell version available on the Director                             |

See the following example:

```json
{
    "deployment_name": "service-instance_$GUID",
    "releases": [{
        "name": "kafka",
        "version": "dev.42",
        "jobs": [
            "kafka_node",
            "zookeeper"
        ]
    }],
    "stemcell": {
        "stemcell_os": "BeOS",
        "stemcell_version": "2"
    }
}
```

Keep in mind the following:

* ODB only supports injecting one stemcell into each service deployment. Different instance groups cannot have different stemcells.
* ODB only supports using exact release and stemcell versions. The use of `latest` and floating stemcells are not supported.
* Your Service Adapter should be opinionated about which jobs it requires to generate its manifest. For example, the Kafka example requires `kafka_node` and `zookeeper`. It should not be opinionated about the mapping of BOSH release to job. The jobs can all be provided by one release, or across many. The SDK provides the helper function [`GenerateInstanceGroupsWithNoProperties`](https://github.com/pivotal-cf/on-demand-services-sdk/blob/master/serviceadapter/instance_group_mapping.go) for generating instance groups without any properties. The Kafka example service adapter [uses this helper function](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/adapter.go) and [invokes it](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) to map the service releases parameter to the BOSH manifest `releases` and `instance_groups` sections.
* You should provide documentation about which jobs are required by your Service Adapter, and which BOSH releases operators should get these jobs from.

**<a id="plan-json"></a>PLAN-JSON**

`PLAN-JSON` specifies the plan for which the manifest is supposed to be generated. The following table describes the schema of the JSON structure required for `PLAN-JSON`:

| field                                     | Type                     | Description                                                                                                                            |
|:------------------------------------------|:-------------------------|:---------------------------------------------------------------------------------------------------------------------------------------|
| instance_groups                           | array of instance groups | instance groups configured for the plan                                                                                                |
| instance_group.name                       | string                   | name of the instance group                                                                                                             |
| instance_group.vm\_type                   | string                   | the vm_type configured for the instance group, matches one in the cloud config on the director                                         |
| instance_group.vm\_extensions             | array of strings         | Optional, the vm_extensions configured for the instance group, must be present in the cloud config on the director                     |
| instance_group.persistent\_disk\_type     | string                   | Optional, the persistent\_disk\_type configured for the instance group, matches one in the cloud config on the director                |
| instance_group.networks                   | array of strings         | the networks the instance group is supposed to be in                                                                                   |
| instance_group.instances                  | int                      | number of instances for the instance group                                                                                             |
| instance_group.lifecycle                  | string                   | Optional, specifies the kind of workload the instance group represents. Valid values are `service` and `errand`; defaults to `service` |
| instance_group.azs                        | array of strings         | a list of availability zones that the instance groups should be striped across                                                         |
| instance_group.migrated\_from             | array of migrations      | Optional, list of [bosh migrations](https://bosh.io/docs/migrated-from.html)                                                           |
| migration.name                            | string                   | Optional, name of the instance group to be migrated from                                                                               |
| properties                                | map                      | properties which the operator has configured for deployments of the current plan                                                       |
| lifecycle\_errands                        | map                      | Optional, details of post-deploy and pre-delete errands                                                                                |
| lifecycle\_errands.post\_deploy           | array of errands         | Optional, post-deploy errands configured for the plan                                                                                  |
| lifecycle\_errands.pre\_delete            | array of errands         | Optional, pre-delete errands configured for the plan                                                                                   |
| errand.name                               | string                   | Errand name                                                                                                                            |
| errand.instances                          | array of strings         | Optional, for a colocated errand, specify a list of INSTANCE-NAME/INSTANCE-IDX to run the errand                                       |
| update                                    | map                      | update block which the operator has configured for deployments of the current plan                                                     |
| update.canaries                           | int                      | plan-specific number of canary instances                                                                                               |
| update.max\_in\_flight                    | int                      | plan-specific maximum number of non-canary instances to update in parallel                                                             |
| update.canary\_watch\_time                | string                   | plan-specific time in milliseconds that the BOSH Director sleeps before checking whether the canary instances are healthy              |
| update.update\_watch\_time                | string                   | plan-specific time in milliseconds that the BOSH Director sleeps before checking whether the non-canary instances are healthy          |
| update.serial                             | boolean                  | Optional, plan-specific flag to deploy instance groups sequentially (`true`), or in parallel (`false`); defaults to `true`             |

See the following example:

```json
{
  "instance_groups": [
    {
      "name": "example-server",
      "vm_type": "small",
      "vm_extensions": [
        "some",
        "extensions"
      ],
      "persistent_disk_type": "ten",
      "networks": [
        "example-network"
      ],
      "azs": [
        "example-az"
      ],
      "instances": 1,
      "migrated_from": [
        {
          "name": "old-example-server"
        }
      ]
    },
    {
      "name": "example-migrations",
      "vm_type": "small",
      "persistent_disk_type": "ten",
      "networks": [
        "example-network"
      ],
      "instances": 1,
      "lifecycle": "errand"
    }
  ],
  "properties": {
    "example": "property"
  },
  "lifecycle_errands": {
    "post_deploy": [
      {
        "name": "health-check"
      },
      {
        "name": "init-replication",
        "instances": ["master-node/0"]
      }
    ],
    "pre_delete": [
      {
        "name": "cleanup",
        "instances": ["example-server/0"]
      }
    ]
  },
  "update": {
    "canaries": 1,
    "max_in_flight": 2,
    "canary_watch_time": "1000-30000",
    "update_watch_time": "1000-30000",
    "serial": true
  }
}
```

Plans are composed by the operator and consist of resource mappings, properties and an optional update block:

* **Resource Mappings**

  The `instance_groups` section of the plan JSON. This maps service deployment instance groups (defined by the service author) to resources (defined by the operator). The service developers should document the list of instance group names required for their deployment (e.g. "redis-server") and any constraints they recommend on resources (e.g. operator must add a persistent disk if persistence property is enabled). These constraints can of course be enforced in code. The `instance_groups` section also contains a field for `lifecycle`, which can be set by the operator. The service adapter will add a lifecycle field to the instance group within the BOSH manifest when specified.

* **Properties**

  Properties are service-specific parameters chosen by the service author. The Redis example exposes a property `persistence`, which takes a boolean value and toggles disk persistence for Redis. These should be documented by the service developers for the operator.

* **Update Block (optional)**

  This block defines a plan-specific configuration for BOSH's update instance operation. Although the ODB considers this block optional, the service adapter must output an update block in every manifest it generates. Some ways to achieve that are:

  1. *(Recommended)* Define a default update block for all plans, which is used when a plan-specific update block is not provided by the operator
  1. Hard code an update block for all plans in the service adapter
  1. Make the update block mandatory, so that operators must provide an update block for every plan in the service catalogue section of the ODB manifest

**<a id="generate-request-params-JSON"></a>REQUEST-PARAMS-JSON**

This is a JSON object that holds the entire body of the [service provision](http://docs.cloudfoundry.org/services/api.html#provisioning) or [service update](http://docs.cloudfoundry.org/services/api.html#updating_service_instance) request sent by the Cloud Controller to the service broker. The request parameters JSON will be `null` for upgrades.

The field `context` holds platform specific contextual information under which the service instance is to be provisioned.

The field `parameters` contains arbitrary key-value pairs which were passed by the application developer as a `cf` CLI parameter when creating, or updating the service instance.

<p class="note"><strong>Note</strong>: When updating an existing service instance, any arbitrary parameters passed on a previous create or update will not be passed again. Therefore, for arbitrary parameters to stay the same across multiple deployments they must be retrieved from the previous manifest.</p>

See the following example:

```
{
  "context": {
    "platform": "cloudfoundry",
    "some_field": "some-contextual-data"
  },
  "organization_guid": "org-guid-here",
  "parameters": {
    "parameter1": {
      "sub-param1": 1,
      "sub-param2": "some-info"
    }
  },
  "plan_id": "plan-id-here",
  "service_id": "service-id-here",
  "space_guid": "space-guid-here"
}
```

**<a id="previous-manifest"></a>PREVIOUS-MANIFEST-YAML**

`PREVIOUS-MANIFEST-YAML` represents the previous BOSH deployment manifest for 
the service instance. If you have a new deployment, the YAML file is empty. 

The manifest format matches the BOSH v2 manifest. For more information about the 
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in 
the BOSH documentation.

The service author must perform any necessary service-specific migration logic if 
previous manifest is non-nil.

Another use-case of the previous manifest is for the migration of deployment properties 
which need to stay the same across multiple deployments of a manifest. In the Redis example, 
we [generate a password](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L112-L123) when we do a new deployment. 
But when the previous deployment manifest is provided, we copy the password over from [the 
previous deployment](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L333-L338), as generating a new 
password for existing deployments will break existing bindings.

For example see the [example Redis service adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_manifest_generator.go#L333-L338).

**<a id="previous-plan"></a>PREVIOUS-PLAN-JSON**

This argument takes the previous plan as a JSON string.

The previous plan is nil if this is a new deployment.

The format of the plan should match the [plan schema](#plan-schema). The previous plan 
can be used for complex plan migration logic. For an example, the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L27:L33)
 rejects a plan migration if the new plan reduces the number of instances, to prevent data loss.

##### <a id="generate-manifest-output"></a>Output

The following table describes the supported exit codes and output for the `generate-manifest` subcommand:

| exit code     | Description     | Output                                                                                                                           |
|:--------------|:----------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success         | Stdout: BOSH manifest YAML                                                                                                       |
| 10            | not implemented |                                                                                                                                  |
| anything else | failure         | Stdout: optional error message for CF CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

---

#### <a id="dashboard-url"></a>dashboard-url

For more information about the `dashboard-url` subcommand, see the following sections:

- [Input Parameters](#dashboard-url-parameters)
- [Output](#dashboard-url-output)

#####<a id="dashboard-url-parameters"></a>Input Parameters

The following section details the parameters provided to the `dashboard-url` subcommand using stdin.

See the following example:

```json
{
  "dashboard_url": {
    "instance_id": "SERVICE-INSTANCE-ID",
    "plan": "PLAN-JSON",
    "manifest": "MANIFEST-YAML"
  }
}
```

All the arguments are passed as strings and not JSON objects. 
See the following example:

```
not-json
{
  "dashboard_url": {
    // ...
    "manifest": "---\nname: some-name\n..."
  }
}
```

**<a id="dashboard-url-instance-id"></a>INSTANCE-ID**

This parameter is the unique identifier of the service instance 
provided by the Cloud Controller. For example, `42a09f38-c15b-47fe-a24e-ebf5f83ebd0`.

**<a id="dashboard-url-plan"></a>PLAN-JSON**

This parameter is the current plan for the service instance as JSON. 
The structure should be the same as the [plan given in the generate manifest](#plan).

See the following example:

```
json
{
  "properties": {
    "persistence": true
  },
  "lifecycle_errands": {
    "post_deploy": [],
    "pre_delete": []
  },
  "instance_groups": [
    {
      "name": "my-example-server",
      "vm_type": "t2.small",
      "persistent_disk_type": "10GB",
      "instances": 1,
      "networks": [
        "default"
      ],
      "azs": [
        "z1"
      ]
    }
  ]
}
```

<br>

**<a id="dashboard-url-manifest"></a>MANIFEST-YAML**

This parameter is the current manifest as YAML.

The manifest format matches the BOSH v2 manifest. For more information about the 
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in 
the BOSH documentation.

See the following example:

```yaml
name: my-service-instance
releases:
- name: my-service
  version: 1.1.0
stemcells:
- alias: only-stemcell
  os: ubuntu-trusty
  version: "3468.1"
instance_groups:
- name: my-example-server
  instances: 1
  jobs:
  - name:  my-example-server
    release: my-service
  vm_type: t2.small
  stemcell: only-stemcell
  persistent_disk_type: 10GB
  azs:
  - z1
  networks:
  - name: default
  properties:
    some-parameter:
      param1: "some-value"
      param2: 1
update:
  canaries: 4
  canary_watch_time: 30000-240000
  update_watch_time: 30000-240000
  max_in_flight: 4
tags:
  product: my-product
addons:
- name: some-addon
  jobs:
  - name: my-example-server
    release: my-service
```

##### <a id="dashboard-url-output"></a>Output

If the `dashboard-url` command generates a url successfully, the shell 
exits with 0 and outputs JSON with the following structure:


| field         | Type   | Description                           |
|:--------------|:-------|:--------------------------------------|
| dashboard_url | string | dashboard url returned to the cf user |

See the following example:

```
{
   "dashboard_url":"https://someurl.example.com"
}
```

#### Supported Exit Codes for dashboard-url

See the following table for supported exit codes for the `dashboard-url` subcommand:

| exit code     | Description     | Output                                                                                                                           |
|:--------------|:----------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success         | Stdout: dashboard URL JSON                                                                                                       |
| 10            | not implemented |                                                                                                                                  |
| anything else | failure         | Stdout: optional error message for CF CLI users<br> 
Stderr: error message for operator<br> 
ODB will log both stdout and stderr |

---

#### <a id="create-binding"></a>create-binding

Binding credentials for a service instance should share a namespace, and should
be unique if possible.

For MySQL, two bindings could include a different username/password pairs, but
share the same MySQL database tables and data.  The first step is to determine
which credentials are best to supply in the context of your service.  Pivotal
recommends that users can be identified statelessly from the binding ID, and
the simplest way to do this is to name the user after the binding ID.

- [Input Parameters](#create-binding-parameters)
- [Output](#create-binding-output)

##### <a id="create-binding-parameters"></a>Input Parameters

The following section details the parameters required by the `create-binding` subcommand as 
a JSON document using stdin.

```json
{
  "create_binding": {
    "binding_id": "BINDING-ID",
    "bosh_vms": "BOSH-VMS-JSON",
    "manifest": "MANIFEST-YAML",
    "request_parameters": "REQUEST-PARAMETERS-JSON"
  }
}
```

All the arguments are passed as strings and not JSON objects. 
See the following example:

```not-json
{
  "create_binding": {
    // ...
    "bosh_vms": "{\"mysql_node\": [\"192.0.2.1\", \"192.0.2.2\", \"192.0.2.3\"]}"
  }
}

```

**<a id="create-binding-id"></a>BINDING-ID**

This parameter is the binding ID generated by the Cloud Controller.

**<a id="create-bosh-vms-json"></a>BOSH-VMS-JSON**

This parameter is a JSON map of instance group name to an array of IPs 
provisioned for that instance group.

See the following example:

```json
{
  "mysql_node": ["192.0.2.1", "192.0.2.2", "192.0.2.3"],
  "management_box": ["192.0.2.4"]
}
```

This can be used to connect to the instance deployment if required, or to create a service specific binding. 
In the example above, the Service Adapter may connect to MySQL as the admin and create a user. 
As part of the binding, the `mysql_node` IPs would be returned, but  not the `management_box`.

**<a id="create-binding-manifest"></a>MANIFEST-YAML**

This parameter is the current manifest as YAML. 
This is used to extract information about the deployment that is necessary for the binding, such as admin credentials with which to create users. 

The manifest format matches the BOSH v2 manifest. For more information about the 
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in 
the BOSH documentation.

**<a id="create-request-params-JSON"></a>REQUEST-PARAMS-JSON**

This parameter is a JSON object that holds the entire body of the [service
binding](http://docs.cloudfoundry.org/services/api.html#binding) request sent
by the Cloud Controller to the service broker.

The field `parameters` contains arbitrary key-value pairs which were passed by
the application developer as a `cf` CLI parameter when creating, or updating
the service instance. 
If using the <a href="#sdk">golang SDK</a>, it can be
obtained using the `ArbitraryParams()` helper method on requestParams.

The field `bind_resource` contains key-value pairs for `app_guid`,
`credential_client_id` and `route`.  If using the <a href="#sdk">golang
SDK</a>, the `brokerapi.BindResource` struct containing these fields can be
accessed using the `BindResource()` helper method on requestParams.

See the following example:

```json
{
  "app_guid": "app-guid-here",
  "bind_resource": {
    "app_guid": "app-guid-here"
  },
  "context": {
    "platform": "cloudfoundry",
    "some_param": "some-value"
  },
  "parameters": {
    "parameter1": {
      "sub-param1": 1,
      "sub-param2": "some-info"
    }
  },
  "plan_id": "my-plan",
  "service_id": "my-service"
  }
  ```

##### <a id="create-binding-credentials"></a>Credentials for Bindings

You can take one of three approaches to credentials for a service binding:

**Static Credentials**

In this case, the same credentials are used for all bindings. One option is to define these credentials in the service instance manifest.

This scenario makes sense for services that use the same credentials for all bindings, such as Redis. For example:

```yaml
properties:
  redis:
    password: PASSWORD
```

**Credentials Unique to Each Binding**

In this case, when the adapter `generate-manifest` subcommand is invoked, 
it generates random admin credentials and returns them as part of the service 
instance manifest. When the `create-binding` subcommand is invoked, the adapter 
can use the admin credentials from the manifest to create unique credentials 
for the binding. Subsequent `create-binding`s create new credentials.

This option makes sense for services whose binding creation resembles user creation, 
such as MySQL or RabbitMQ. For example, in MySQL the admin user can be used to create 
a new user and database for the binding:

```yaml
properties:
  admin_password: ADMIN-PASSWORD
```

**Using an Agent**

In this case, the author defines an agent responsible for handling creation of 
credentials unique to each binding. The agent must be added as a BOSH release 
in the service manifest. Moreover, the service and agent jobs should be co-located 
in the same instance group.

This option is useful for services where the adapter cannot or prefers not to 
directly call out to the service instance, and instead delegates responsibility 
for setting up new credentials to an agent.

See the following example:

```yaml
releases:
  - name: service-release
    version: 1.5.7
  - name: credentials-agent-release
    version: 4.2.0

instance_groups:
  - name: service-group
    jobs:
      - name: service-job
        release: service-release
      - name: credentials-agent-job
        release: credentials-agent-release
```

##### <a id="create-binding-output"></a>Output

If the `create-binding` command is successful, the shell outputs an exit code of 0 
and prints a service broker API binding JSON response on stdout. 

If the command fails, the shell returns a non-zero exit code. Stdout and stderr 
from the command will be logged by the ODB.

For more information about supported failure cases, see [Supported Exit Codes 
for Binding](#create-binding-exit-codes) below.

The following is an example success response to `create-binding`:

```
json
{
  "credentials": {
    "username": "user1",
    "password": "reallysecret"
  },
  "syslog_drain_url": "optional: for syslog drain services only",
  "route_service_url": "optional: for route services only"
}
```

**<a id="create-binding-exit-codes"></a>Supported Exit Codes for Binding**

| exit code     | Description                                       | Output                                                                                                                           |
|:--------------|:--------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                                           | Stdout: binding credentials JSON                                                                                                 |
| 10            | subcommand not implemented                        |                                                                                                                                  |
| 42            | app_guid not provided in the binding request body | Stderr: error message for operator<br/> ODB will log both stdout and stderr                                                      |
| 49            | binding already exists                            | Stderr: error message for operator<br/> ODB will log both stdout and stderr                                                      |
| anything else | failure                                           | Stdout: optional error message for CF CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

---

#### <a id="delete-binding"></a>delete-binding

- [Input Parameters](#delete-binding-parameters)
- [Output](#delete-binding-output)

This subcommand should invalidate the credentials that were generated by
`create-binding` if possible.  For example, the subcommand would
delete the binding user in MySQL.

##### <a id="delete-binding-parameters"></a>Input Parameters

This section describes the parameters required by the `delete-binding` subcommand.

See the following example:

```json
{
  "delete_binding": {
    "binding_id": "BINDING-ID",
    "bosh_vms": "BOSH-VMS-JSON",
    "manifest": "MANIFEST-YAML",
    "delete_parameters": "DELETE-PARAMETERS-JSON"
  }
}
```

All the arguments are passed as strings and not JSON objects. 
See the following example:

```not-json
{
  "delete_binding": {
    // ...
    "manifest": "---\nname: some-name\n..."
  }
}

```

**<a id="delete-binding-id"></a>BINDING-ID**

This parameter is the binding to be deleted.

**<a id="delete-binding-vm-json"></a>BOSH-VMS-JSON**

This parameter is a map of instance group name to an array of IPs provisioned for that instance group.

See the following example:

```json
{
  "my-instance-group": ["192.0.2.1", "192.0.2.2", "192.0.2.3"]
}
```

**<a id="delete-binding-manifest"></a>MANIFEST-YAML**

`MANIFEST-YAML` represents the parameter for the current manifest.
BOSH uses the manifest to extract information about the deployment 
such as the credentials.

The manifest format matches the BOSH v2 manifest. For more information about the 
BOSH v2 manifest, see [Deployment Config](https://bosh.io/docs/manifest-v2/) in 
the BOSH documentation.

For an example, see the [Kafka delete binding](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/delete_binding.go).

**<a id="delete-params-JSON"></a>DELETE-PARAMS-JSON**

This parameter is a JSON object that holds query string parameters as useful hints for service brokers. For more information, see the Open Service Broker API [documentation](http://docs.cloudfoundry.org/services/api.html#unbinding).

See the following example:

```json
{
  "plan_id":"my-plan-id",
  "service_id":"my-service-id"
}
```

<p class="note"><strong>Note</strong>: This parameter is different from the
  create-binding <code>request_parameters</code> parameter, and in particular
  does not include <code>parameters</code> or <code>bind_resource</code>.</p>

##### <a id="delete-binding-output"></a>Output

The following table describes the supported exit codes and output for the `delete-binding` subcommand:

| exit code     | Description            | Output                                                                                                                           |
|:--------------|:-----------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                | No output is required                                                                                                            |
| 10            | not implemented        |                                                                                                                                  |
| 41            | binding does not exist | Stderr: error message for operator<br/> ODB will log both stdout and stderr                                                      |
| anything else | failure                | Stdout: optional error message for CF CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |


This can be used to connect to the actual VMs if required, to delete a service specific binding.
For example, this can be used to delete a user in MySQL.

---

#### <a id="generate-plan-schemas"></a>generate-plan-schemas

- [Input Parameters](#generate-plan-schemas-parameters)
- [Output](#generate-plan-schemas-output)

The broker uses the schema returned by the subcommand to validate service-specific configuration parameters.
Apps Manager uses the schema to generate a form that users can use to populate those parameters.
The schema must be in the JSON Schema draft-04 format.

For more information about the plan schema, see the [Open Service Broker API (OSBAPI) v2.13
specification](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#schema-object).

If you do not want to validate all parameters and want additional parameters to
be accepted without constraints, set the JSON schema field `additionalProperties` to `true`.
For the location of this field, see the [Kafka example
adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_plan_schemas.go#L43-L59).
For example, you might use this if you want to accept an
undocumented optional parameter, for administration purposes, that should not be
exposed through the Apps Manager UI.

##### <a id="generate-plan-schemas-parameters"></a>Input Parameters

This section describes the parameters required by the `generate-plan-schemas` 
subcommand, passed using stdin.

```json
{
  "generate_plan_schemas": {
    "plan": "PLAN-JSON"
  }
}
```

All the arguments are passed as strings and not JSON objects. 
See the following example:

```not-json
{
  "generate_plan_schemas": {
    "plan": "{\"instance_groups\":[]}"
  }
}

```

**<a id="plan-json"></a>PLAN-JSON**

This parameter is the service plan as JSON required to generate the JSON schema.

See the following example:

```json
{
  "properties": {
    "persistence": true
  },
  "lifecycle_errands": {
    "post_deploy": [],
    "pre_delete": []
  },
  "instance_groups": [
    {
      "name": "my-example-server",
      "vm_type": "t2.small",
      "persistent_disk_type": "10GB",
      "instances": 1,
      "networks": [
        "default"
      ],
      "azs": [
        "z1"
      ]
    }
  ]
}
```

##### <a id="generate-plan-schemas-output"></a>Output

The following table describes the supported exit codes and output for the 
`generate-plan-schemas` subcommand:

| exit code     | Description            | Output                                                                                                                           |
|:--------------|:-----------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| 0             | success                | No output is required                                                                                                            |
| 10            | not implemented        |                                                  |
| anything else | failure                | Stdout: optional error message for cf CLI users<br/> Stderr: error message for operator<br/> ODB will log both stdout and stderr |

## <a id="packaging"></a>Packaging

This section describes workflows for setting up and maintaining of a service instance. 
The diagrams show which tasks are undertaken by the ODB and which require interaction 
with the Service Adapter.

The adapter should be packaged as a BOSH release, which should be co-located with the 
ODB release in a BOSH manifest by the operator. 
This is only done in order to place the adapter executable on the same VM as the ODB 
server. As a result, the adapter BOSH job's `monit` file should  have no processes defined.

See the following example service adapter releases:

- <a href="https://github.com/pivotal-cf-experimental/kafka-example-service-adapter-release">Kafka</a>
- <a href="https://github.com/pivotal-cf-experimental/redis-example-service-adapter-release">Redis</a>

## <a id="sdk"></a> Golang SDK

Pivotal has published a [SDK](https://github.com/pivotal-cf/on-demand-services-sdk) for 
teams writing their service adapters in Golang. It encapsulates the command line invocation 
handling, parameter parsing, response serialization and error handling so the adapter authors 
can focus on the service-specific logic in the adapter.

Use the same version of the SDK as your ODB release. For example, if you are using v0.8.0 of 
the ODB BOSH release, you should check out the v0.8.0 tag of the SDK.

For the generated BOSH manifest, the SDK supports properties in two levels: manifest global and job level. 
Global properties are [deprecated in BOSH](http://bosh.io/docs/manifest-v2.html#properties), in favor 
of job level properties and job links. 

As an example, refer to the [Kafka example service adapter property generation](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/ffe85fecc2d9cf1b663fab418875e67ddcf3327f/adapter/generate_manifest.go#L79-L123).

### <a id="sdk_usage"></a>Use the SDK

Perform the following steps to use the SDK:

1. Run the following `go get` command to install the SDK:

  ```
  go get github.com/pivotal-cf/on-demand-services-sdk
  ```

1. In the main function for the service adapter, call the `HandleCLI` function: 

  ```go
  package main

  import (
  	"log"
  	"os"

  	"github.com/bar-org/foo-service-adapter/adapter"
  	"github.com/pivotal-cf/on-demand-services-sdk/serviceadapter"
  )

  func main() {
    logger := log.New(os.Stderr, "[foo-service-adapter] ", log.LstdFlags)
    manifestGenerator := adapter.ManifestGenerator{}
    binder := adapter.Binder{}
    dashboardUrlGenerator := adapter.DashboardUrlGenerator{}
  	handler := serviceadapter.CommandLineHandler{
    	ManifestGenerator:     manifestGenerator,
    	Binder:                binder,
    	DashboardURLGenerator: &adapter.DashboardUrlGenerator{},
    	SchemaGenerator:       adapter.SchemaGenerator{},
  	}
    serviceadapter.HandleCLI(os.Args, handler)
  }
  ```
<p class="note"><strong>Note</strong>: The HandleCommandLineInvocation function is being deprecated but its functionality can be seen <a href="https://docs.pivotal.io/svc-sdk/odb/0-19/creating.html#usage">here</a>.</p>

### <a id="interfaces"></a>Interfaces

The `HandleCLI` function accepts structs that implement the following interfaces:

```go
type CommandLineHandler struct {
	ManifestGenerator     ManifestGenerator
	Binder                Binder
	DashboardURLGenerator DashboardUrlGenerator
	SchemaGenerator       SchemaGenerator
}

type ManifestGenerator interface {
	GenerateManifest(serviceDeployment ServiceDeployment, plan Plan, requestParams RequestParameters, previousManifest *bosh.BoshManifest, previousPlan *Plan) (bosh.BoshManifest, error)
}

type Binder interface {
	CreateBinding(bindingID string, deploymentTopology bosh.BoshVMs, manifest bosh.BoshManifest, requestParams RequestParameters) (Binding, error)
	DeleteBinding(bindingID string, deploymentTopology bosh.BoshVMs, manifest bosh.BoshManifest, requestParams RequestParameters) error
}

type DashboardUrlGenerator interface {
	DashboardUrl(instanceID string, plan Plan, manifest bosh.BoshManifest) (DashboardUrl, error)
}

type SchemaGenerator interface {
	GeneratePlanSchema(plan Plan) (PlanSchema, error)
}
```

### <a id="helper_function"></a>Helpers

The helper function `GenerateInstanceGroupsWithNoProperties` can generate the
instance groups for the BOSH manifest from the arguments passed to the adapter.

One of the inputs for this function is `deploymentInstanceGroupsToJobs`,
where instance groups are mapped to jobs for the deployment.
The service author must provide this mapping.
The helper function does not address job level properties for the generated instance groups;
the service author must provide these properties.
For an example implementation, see the job mapping in the [Kafka example
adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go#L15-L21).

The SDK provides the methods `ArbitraryContext` and `Platform`. These are
used to extract the `context` property from the request parameters and the `platform` property from within the
`context`.

The context in the response is a feature of [Open Service Broker API (OSBAPI) v2.13 
specification](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md)
and is used to pass through information about the environment in which the
platform or application is executing. If the platform does not provide a `context`, the SDK returns empty values.

### <a id="error_handling"></a>Error Handling

Any error returned by the interface functions is considered to be for the Cloud Foundry CLI user and will accordingly be printed to stdout.

The adapter code is responsible for performing any error logging to stderr that the authors think is relevant for the operator logs.

There are three specialised errors for the `CreateBinding` function, which allow the adapter to exit with the appropriate code:

```go
serviceadapter.NewBindingAlreadyExistsError()
serviceadapter.NewBindingNotFoundError()
serviceadapter.NewAppGuidNotProvidedError()
```

For more complete code examples please take a look at the [Kafka adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter) or the [Redis adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter).

### <a id="bosh_features"></a>BOSH Features

Service authors can enable configuration of BOSH Features in their service adapters.

The SDK provides the following [BoshFeatures struct](https://github.com/pivotal-cf/on-demand-services-sdk/blob/49cf3649cd34db8715b673d42e36710517e0f30e/bosh/bosh_manifest.go#L36-L45) 
with the possibility of adding extra features via the `ExtraFeatures` map:

```
type BoshFeatures struct {
	UseDNSAddresses      *bool                  `yaml:"use_dns_addresses,omitempty"`
	RandomizeAZPlacement *bool                  `yaml:"randomize_az_placement,omitempty"`
	UseShortDNSAddresses *bool                  `yaml:"use_short_dns_addresses,omitempty"`
	ExtraFeatures        map[string]interface{} `yaml:"extra_features,inline"`
}
```

For an example, see the [Redis adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/4f78b89d791733d025ae96f4056eb6840989818e/adapter/redis_manifest_generator.go#L215-L222).

For more information on BOSH Features, see [the BOSH documentation](https://bosh.io/docs/manifest-v2.html#features).
